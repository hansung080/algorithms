Title  : Project02. Custom Data Structure
Writer : Kwon Han Seong
Date   : 2016-06-03

==============================================================================================================
<< Project 빌드 및 실행 >>
==============================================================================================================
1. 빌드 : Makefile을 이용하여, Linux 환경에서 빌드 진행
  -> Build Command : make

2. 실행 : 단위 테스트를 Linux 환경에서 진행
  -> Execute Command : ./test

==============================================================================================================
<< ArrayList 디자인 설명>>
==============================================================================================================
1. ArrayList 추가, 검색, 삭제 기능
  -> 추가 기능 : 리스트 내부 배열의 데이터 뒤쪽에 순차적으로 신규 데이터가 추가됨 (함수: addList)
  -> 검색 기능 : 리스트에 데이터가 존재하는지 확인한 후, 배열의 첫번째 데이터부터 마지막 데이터까지 순차적으로
                 검색을 진행함(함수: isNextDataExist, getNextData)
  -> 삭제 기능 : 리스트에 데이터가 존재하는지 확인한 후, 순차적으로 삭제를 진행함. 그리고, 검색기능을 활용하여
                 원하는 ID의 데이터만 삭제할 수도 있음. (함수: isNextDataExist, removeNextData)

2. ArrayList 특이사항
  -> 범용 리스트 구현을 위해, LIST 구조체 내부에는 배열의 주소값만 저장
     (void* 를 활용하여, Java Generic, C++ Template 처럼, 범용 리스트를 구현하였음)
  -> 리스트 초기화시, 사용자가 선언한 배열의 주소값, 데이터 크기, 최대 테이터 개수를 파라미터로 넘겨 주어야 함.
     (사용자 입장에서는 조금 불편할 수도 있지만, C언어에서 범용 리스트 구현을 위해 불가피한 선택이었음)
  -> 데이터 추가, 검색, 삭제시, 데이터 크기를 고려하여 추가, 검색, 삭제의 위치를 계산하였음.

3. ArrayList 단위 테스트
  -> PERSON 구조체를 선언하여, 5개의 PERSON 정보를 추가하고 검색한 후, 1개의 PERSON 정보를 삭제하고 다시 검색함.

4. ArrayList 개선사항
  -> 뮤텍스를 활용하여 스레드 동기화를 시도하였으나, 런타임 에러가 발생(아직 문제를 해결하지 못했음)
  -> 정렬 기능등을 추가 가능

==============================================================================================================
<< HashMap 디자인 설명>>
==============================================================================================================
1. HashMap 추가, 검색, 삭제 기능
  -> 추가 기능 : 내부 테이블에 해쉬 함수에 의해 변형된 키(Hash Value)에 따라 데이터를 저장함. (함수: addMap)
  -> 검색 기능 : 키를 파라미터로 넘기면, 그에 매칭되는 데이터를 반환함.(함수: getMap)
  -> 삭제 기능 : 키를 파라미터로 넘기면, 그에 매칭되는 데이터를 삭제함.(함수: removeMap)

2. HashMap 특이사항
  -> 키에 따라 좋은 해쉬 함수가 달라지기 때문에, 사용자가 해쉬 함수를 정의하여 초기화시 파라미터로 넘겨 주도록
     하였음. (함수 포인터 이용)
  -> 키는 다름에도 불구하고 Hash Value가 같아져서 발생하는 충돌 문제를 해결하기 위해 Linked List를 활용함.
     내부 해쉬 테이블의 엔트리를 Linked List로 구현하여, Hash Value가 같은 데이터들이 테이블의 같은 위치에 연결
     리스트 형태로 저장되게 됨.

3. HashMap 단위 테스트
  -> PERSON 구조체를 선언하여, 5개의 PERSON 정보를 추가하고 검색한 후, 1개의 PERSON 정보를 삭제하고 다시 검색함.
  -> 충돌 문제를 테스트하기 위해, 1번 PERSON과 5번 PERSON의 Hash Value를 같게하여 테스트한 결과, 문제가 없었음.

4. HashMap 개선사항
  -> 뮤텍스를 활용하여 스레드 동기화를 시도하였으나, 런타임 에러가 발생(아직 문제를 해결하지 못했음)
  -> HashMap, Linked List를 범용으로 구현하지 못했음
    (다른 데이터를 저장하기 위해서는 헤더 파일의 typedef 선언을 변경해야 함)

==============================================================================================================
<< HashSet 디자인 설명>>
==============================================================================================================
  -> 시간이 부족하여 구현하지 못했습니다.


